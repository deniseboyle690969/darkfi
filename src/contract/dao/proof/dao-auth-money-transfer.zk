k = 13;
field = "pallas";

constant "DaoAuthMoneyTransfer" {
	EcFixedPointShort VALUE_COMMIT_VALUE,
	EcFixedPoint VALUE_COMMIT_RANDOM,
}

witness "DaoAuthMoneyTransfer" {
	# Proposal parameters
    Base proposal_auth_calls_commit,
    Base proposal_user_data,
	Base proposal_blind,

	# DAO parameters
	Base dao_proposer_limit,
	Base dao_quorum,
	Base dao_approval_ratio_quot,
	Base dao_approval_ratio_base,
	Base gov_token_id,
	Base dao_public_x,
	Base dao_public_y,
	Base dao_bulla_blind,

	# Votes
	Base yes_vote_value,
	Base all_vote_value,
	Scalar yes_vote_blind,
	Scalar all_vote_blind,
}

circuit "DaoAuthMoneyTransfer" {
	dao_bulla = poseidon_hash(
		dao_proposer_limit,
		dao_quorum,
		dao_approval_ratio_quot,
		dao_approval_ratio_base,
		gov_token_id,
		dao_public_x,
		dao_public_y,
		dao_bulla_blind,
	);

	# Proposal bulla being valid means DAO bulla is also valid because
	# dao-propose-main.zk already checks that when we first create the
	# proposal - so it is redundant to check DAO bulla exists here.
	proposal_bulla = poseidon_hash(
        proposal_auth_calls_commit,
        proposal_user_data,
		dao_bulla,
		proposal_blind,
	);
	constrain_instance(proposal_bulla);

    # Check inputs are spending from the correct DAO
    # Change output should be sending back to the DAO

    # Reveal content commit. This should contain the set of coins.
    # We check these are set in the runtime.
}

