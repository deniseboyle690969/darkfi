use std::io;

use crate::{
    crypto::{keypair::PublicKey, schnorr::Signature},
    impl_vec, net,
    util::serial::{Decodable, Encodable, SerialDecodable, SerialEncodable, VarInt},
    Result,
};

use super::{metadata::Metadata, participant::Participant, tx::Tx, util::Timestamp};

/// This struct represents a tuple of the form (st, sl, txs, metadata).
/// Each blocks parent hash st may be computed simply as a hash of the parent block.
#[derive(Debug, Clone, SerialEncodable, SerialDecodable)]
pub struct Block {
    /// Previous block hash
    pub st: blake3::Hash,
    /// Slot uid, generated by the beacon
    pub sl: u64,
    /// Transactions payload
    pub txs: Vec<Tx>,
    /// Additional block information
    pub metadata: Metadata,
}

impl Block {
    pub fn new(
        st: blake3::Hash,
        sl: u64,
        txs: Vec<Tx>,
        timestamp: Timestamp,
        proof: String,
        r: String,
        s: String,
        participants: Vec<Participant>,
    ) -> Block {
        Block { st, sl, txs, metadata: Metadata::new(timestamp, proof, r, s, participants) }
    }

    pub fn from_proposal(proposal: BlockProposal) -> Block {
        Block { st: proposal.st, sl: proposal.sl, txs: proposal.txs, metadata: proposal.metadata }
    }
}

impl PartialEq for Block {
    fn eq(&self, other: &Self) -> bool {
        self.st == other.st && self.sl == other.sl && self.txs == other.txs
    }
}

impl_vec!(Block);

/// This struct represents a Block proposal, used for consensus.
#[derive(Debug, Clone, SerialEncodable, SerialDecodable)]
pub struct BlockProposal {
    /// leader public key
    pub public_key: PublicKey,
    /// signed block
    pub signature: Signature,
    /// leader id
    pub id: u64,
    /// Previous block hash
    pub st: blake3::Hash,
    /// Slot uid, generated by the beacon
    pub sl: u64,
    /// Transactions payload
    pub txs: Vec<Tx>,
    /// Additional proposal information
    pub metadata: Metadata,
}

impl BlockProposal {
    pub fn new(
        public_key: PublicKey,
        signature: Signature,
        id: u64,
        st: blake3::Hash,
        sl: u64,
        txs: Vec<Tx>,
        timestamp: Timestamp,
        proof: String,
        r: String,
        s: String,
        participants: Vec<Participant>,
    ) -> BlockProposal {
        BlockProposal {
            public_key,
            signature,
            id,
            st,
            sl,
            txs,
            metadata: Metadata::new(timestamp, proof, r, s, participants),
        }
    }
}

impl PartialEq for BlockProposal {
    fn eq(&self, other: &Self) -> bool {
        self.public_key == other.public_key &&
            self.signature == other.signature &&
            self.id == other.id &&
            self.st == other.st &&
            self.sl == other.sl &&
            self.txs == other.txs
    }
}

impl net::Message for BlockProposal {
    fn name() -> &'static str {
        "proposal"
    }
}

impl_vec!(BlockProposal);
