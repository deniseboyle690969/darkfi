use serde::{Deserialize, Serialize};
use std::{
    hash::{Hash, Hasher},
    io,
};

use super::{metadata::Metadata, tx::Tx};

use crate::{
    crypto::{keypair::PublicKey, schnorr::Signature},
    net,
    util::serial::{Decodable, Encodable},
    Result,
};

/// This struct represents a tuple of the form (st, sl, txs, metadata).
/// Each blocks parent hash h may be computed simply as a hash of the parent block.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Block {
    /// Previous block hash
    pub st: String,
    /// Slot uid, generated by the beacon
    pub sl: u64,
    /// Transactions payload
    pub txs: Vec<Tx>,
    /// Additional block information
    pub metadata: Metadata,
}

impl Block {
    pub fn new(st: String, sl: u64, txs: Vec<Tx>, proof: String, r: String, s: String) -> Block {
        Block { st, sl, txs, metadata: Metadata::new(proof, r, s) }
    }
}

impl PartialEq for Block {
    fn eq(&self, other: &Self) -> bool {
        self.st == other.st && self.sl == other.sl && self.txs == other.txs
    }
}

impl Hash for Block {
    fn hash<H: Hasher>(&self, hasher: &mut H) {
        format!("{:?}{:?}{:?}", self.st, self.sl, self.txs).hash(hasher);
    }
}

impl Encodable for Block {
    fn encode<S: io::Write>(&self, mut s: S) -> Result<usize> {
        let mut len = 0;
        len += self.st.encode(&mut s).unwrap();
        len += self.sl.encode(&mut s).unwrap();
        len += self.txs.encode(&mut s).unwrap();
        len += self.metadata.encode(&mut s).unwrap();
        Ok(len)
    }
}

impl Decodable for Block {
    fn decode<D: io::Read>(mut d: D) -> Result<Self> {
        let st = Decodable::decode(&mut d)?;
        let sl = Decodable::decode(&mut d)?;
        let txs = Decodable::decode(&mut d)?;
        let metadata = Decodable::decode(&mut d)?;
        Ok(Self { st, sl, txs, metadata })
    }
}

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub struct BlockProposal {
    /// leader public key
    pub public_key: PublicKey,
    /// signed block
    pub signature: Signature,
    /// leader id
    pub id: u64,
    /// Previous block hash
    pub st: String,
    /// Slot uid, generated by the beacon
    pub sl: u64,
    /// Transactions payload
    pub txs: Vec<Tx>,
}

impl BlockProposal {
    pub fn new(
        public_key: PublicKey,
        signature: Signature,
        id: u64,
        st: String,
        sl: u64,
        txs: Vec<Tx>,
    ) -> BlockProposal {
        BlockProposal { public_key, signature, id, st, sl, txs }
    }
}

impl net::Message for BlockProposal {
    fn name() -> &'static str {
        "proposal"
    }
}

impl Encodable for BlockProposal {
    fn encode<S: io::Write>(&self, mut s: S) -> Result<usize> {
        let mut len = 0;
        len += self.public_key.encode(&mut s).unwrap();
        len += self.signature.encode(&mut s).unwrap();
        len += self.id.encode(&mut s).unwrap();
        len += self.st.encode(&mut s).unwrap();
        len += self.sl.encode(&mut s).unwrap();
        len += self.txs.encode(&mut s).unwrap();
        Ok(len)
    }
}

impl Decodable for BlockProposal {
    fn decode<D: io::Read>(mut d: D) -> Result<Self> {
        let public_key = Decodable::decode(&mut d)?;
        let signature = Decodable::decode(&mut d)?;
        let id = Decodable::decode(&mut d)?;
        let st = Decodable::decode(&mut d)?;
        let sl = Decodable::decode(&mut d)?;
        let txs = Decodable::decode(&mut d)?;
        Ok(Self { public_key, signature, id, st, sl, txs })
    }
}

pub fn proposal_eq_block(proposal: &BlockProposal, block: &Block) -> bool {
    proposal.st == block.st && proposal.sl == block.sl && proposal.txs == block.txs
}
