use std::io;

use log::debug;

use super::{Metadata, StreamletMetadata, Timestamp, Tx};
use crate::{
    crypto::{keypair::PublicKey, schnorr::Signature},
    impl_vec, net,
    util::serial::{serialize, Decodable, Encodable, SerialDecodable, SerialEncodable, VarInt},
    Result,
};

/// This struct represents a tuple of the form (`st`, `sl`, txs`, `metadata`).
#[derive(Debug, Clone, SerialEncodable, SerialDecodable)]
pub struct Block {
    /// Previous block hash
    pub st: blake3::Hash,
    /// Slot uid, generated by the beacon
    pub sl: u64,
    /// Transaction hashes
    pub txs: Vec<blake3::Hash>,
    /// Additional block information
    pub metadata: Metadata,
}

impl Block {
    pub fn new(st: blake3::Hash, sl: u64, txs: Vec<blake3::Hash>, metadata: Metadata) -> Self {
        Self { st, sl, txs, metadata }
    }

    /// Generate the genesis block.
    pub fn genesis_block(genesis_ts: Timestamp, genesis_data: blake3::Hash) -> Self {
        let metadata =
            Metadata::new(genesis_ts, String::from("proof"), String::from("r"), String::from("s"));

        Self::new(genesis_data, 0, vec![], metadata)
    }
}

/// This struct represents a block proposal, used for consensus.
#[derive(Debug, Clone, SerialEncodable, SerialDecodable)]
pub struct BlockProposal {
    /// Leader public key
    pub public_key: PublicKey,
    /// Block signature
    pub signature: Signature,
    /// Leader ID
    pub id: u64,
    /// Previous block hash
    pub st: blake3::Hash,
    /// Slot uid, generated by the beacon
    pub sl: u64,
    /// Transactions payload
    pub txs: Vec<Tx>,
    /// Additional proposal information
    pub metadata: Metadata,
    /// Proposal information used by Streamlet consensus
    pub sm: StreamletMetadata,
}

impl BlockProposal {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        public_key: PublicKey,
        signature: Signature,
        id: u64,
        st: blake3::Hash,
        sl: u64,
        txs: Vec<Tx>,
        metadata: Metadata,
        sm: StreamletMetadata,
    ) -> Self {
        Self { public_key, signature, id, st, sl, txs, metadata, sm }
    }

    /// Produce proposal hash using `st`, `sl`, `txs`, and `metadata`.
    pub fn hash(&self) -> blake3::Hash {
        Self::to_proposal_hash(self.st, self.sl, &self.txs, &self.metadata)
    }

    /// Generate a proposal hash using provided `st`, `sl`, `txs`, and `metadata`.
    pub fn to_proposal_hash(
        st: blake3::Hash,
        sl: u64,
        transactions: &[Tx],
        metadata: &Metadata,
    ) -> blake3::Hash {
        let mut txs = Vec::with_capacity(transactions.len());
        for tx in transactions {
            txs.push(blake3::hash(&serialize(tx)));
        }

        blake3::hash(&serialize(&Block::new(st, sl, txs, metadata.clone())))
    }
}

impl PartialEq for BlockProposal {
    fn eq(&self, other: &Self) -> bool {
        self.public_key == other.public_key &&
            self.signature == other.signature &&
            self.id == other.id &&
            self.st == other.st &&
            self.sl == other.sl &&
            self.txs == other.txs &&
            self.metadata == other.metadata
    }
}

impl net::Message for BlockProposal {
    fn name() -> &'static str {
        "proposal"
    }
}

impl_vec!(BlockProposal);

/// This struct represents a sequence of block proposals.
#[derive(Debug, Clone, PartialEq, SerialEncodable, SerialDecodable)]
pub struct ProposalChain {
    pub genesis_block: blake3::Hash,
    pub proposals: Vec<BlockProposal>,
}

impl ProposalChain {
    pub fn new(genesis_block: blake3::Hash, initial_proposal: BlockProposal) -> Self {
        Self { genesis_block, proposals: vec![initial_proposal] }
    }

    /// A proposal is considered valid when its parent hash is equal to the
    /// hash of the previous proposal and their epochs are incremental,
    /// excluding the genesis block proposal.
    /// Additional validity rules can be applied.
    pub fn check_proposal(&self, proposal: &BlockProposal, previous: &BlockProposal) -> bool {
        if proposal.st == self.genesis_block {
            debug!("check_proposal(): Genesis block proposal provided.");
            return false
        }

        let prev_hash = previous.hash();
        if proposal.st != prev_hash || proposal.sl <= previous.sl {
            debug!("check_proposal(): Provided proposal is invalid.");
            return false
        }

        true
    }

    /// A proposals chain is considered valid when every proposal is valid,
    /// based on the `check_proposal` function.
    pub fn check_chain(&self) -> bool {
        for (index, proposal) in self.proposals[1..].iter().enumerate() {
            if !self.check_proposal(proposal, &self.proposals[index]) {
                return false
            }
        }

        true
    }

    /// Insertion of a valid proposal.
    pub fn add(&mut self, proposal: &BlockProposal) {
        if self.check_proposal(proposal, self.proposals.last().unwrap()) {
            self.proposals.push(proposal.clone());
        }
    }

    /// Proposals chain notarization check.
    pub fn notarized(&self) -> bool {
        for proposal in &self.proposals {
            if !proposal.sm.notarized {
                return false
            }
        }

        true
    }
}

impl_vec!(ProposalChain);
